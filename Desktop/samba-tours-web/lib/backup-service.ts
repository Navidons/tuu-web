import { PrismaClient } from '@prisma/client'
import crypto from 'crypto'

const prisma = new PrismaClient()

interface BackupInfo {
  id: string
  filename: string
  size: string
  createdAt: string
  status: 'completed' | 'in_progress' | 'failed'
  type: 'manual' | 'auto'
  tables: string[]
  recordCount: number
  content?: string // Store backup content in memory for immediate download
}

interface BackupStats {
  totalBackups: number
  totalSize: string
  lastBackup: string
  autoBackupsEnabled: boolean
  nextAutoBackup: string
  storageUsed: string
  storageLimit: string
}

// Global in-memory storage for recent backups (for immediate download)
// Using global to ensure persistence across API calls
declare global {
  var __backupStorage: Map<string, BackupInfo> | undefined
}

if (!global.__backupStorage) {
  global.__backupStorage = new Map<string, BackupInfo>()
}

const recentBackups = global.__backupStorage

export class BackupService {
  private static readonly TABLES = [
    'users',
    'tours',
    'bookings',
    'reviews',
    'blog_posts',
    'newsletter_subscribers',
    'contact_inquiries',
    'visitors',
    'email_templates',
    'email_campaigns',
    'email_sent'
  ]

  /**
   * Create a new backup using Prisma
   */
  static async createBackup(type: 'manual' | 'auto' = 'manual'): Promise<BackupInfo> {
    const backupId = crypto.randomUUID()
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `backup-${type}-${timestamp}-${backupId}.sql`

    console.log('Creating backup:', { backupId, type, filename })
    console.log('Current backups in memory:', Array.from(recentBackups.keys()))

    try {
      // Generate SQL dump using Prisma
      console.log('Generating SQL dump...')
      const backupContent = await this.generateSQLDump()
      console.log('SQL dump generated, length:', backupContent.length)
      
      const size = this.formatBytes(backupContent.length)
      const recordCount = await this.getRecordCount()

      const backupInfo: BackupInfo = {
        id: backupId,
        filename,
        size,
        createdAt: new Date().toISOString(),
        status: 'completed',
        type,
        tables: this.TABLES,
        recordCount,
        content: backupContent
      }

      // Store in memory for immediate download
      recentBackups.set(backupId, backupInfo)
      console.log('Backup stored in memory, total backups:', recentBackups.size)
      console.log('Available backup IDs:', Array.from(recentBackups.keys()))

      // Clean up old backups (keep only last 10)
      if (recentBackups.size > 10) {
        const oldestKey = recentBackups.keys().next().value
        recentBackups.delete(oldestKey)
        console.log('Cleaned up old backup:', oldestKey)
      }

      return backupInfo
    } catch (error) {
      console.error('Backup creation failed:', error)
      throw new Error(`Backup failed: ${error}`)
    }
  }

  /**
   * Generate SQL dump using Prisma queries
   */
  private static async generateSQLDump(): Promise<string> {
    const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ')
    
    let sqlDump = `-- MySQL dump generated by Samba Tours Backup System
-- Generated on: ${timestamp}
-- Database: samba_tours_db

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

-- --------------------------------------------------------

`

    // Generate dumps for each table
    for (const table of this.TABLES) {
      try {
        const data = await this.dumpTable(table)
        sqlDump += data
      } catch (error) {
        console.warn(`Failed to dump table ${table}:`, error)
        sqlDump += `-- Table ${table} could not be dumped due to error\n\n`
      }
    }

    sqlDump += `
-- --------------------------------------------------------

COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
`

    return sqlDump
  }

  /**
   * Dump a specific table
   */
  private static async dumpTable(tableName: string): Promise<string> {
    let sql = `-- Table structure for table \`${tableName}\`\n`
    
    try {
      // Get table structure
      const structure = await prisma.$queryRawUnsafe(`SHOW CREATE TABLE ${tableName}`)
      const createTable = (structure as any)[0]['Create Table']
      
      sql += `DROP TABLE IF EXISTS \`${tableName}\`;\n`
      sql += `${createTable};\n\n`
      
      // Get table data
      const data = await prisma.$queryRawUnsafe(`SELECT * FROM ${tableName}`)
      
      if (Array.isArray(data) && data.length > 0) {
        sql += `-- Dumping data for table \`${tableName}\`\n`
        sql += `INSERT INTO \`${tableName}\` VALUES\n`
        
        const values = data.map((row: any) => {
          const rowValues = Object.values(row).map(value => {
            if (value === null) return 'NULL'
            if (typeof value === 'string') return `'${value.replace(/'/g, "''")}'`
            if (typeof value === 'boolean') return value ? '1' : '0'
            return value
          })
          return `(${rowValues.join(', ')})`
        })
        
        sql += values.join(',\n') + ';\n\n'
      } else {
        sql += `-- No data to dump for table \`${tableName}\`\n\n`
      }
      
    } catch (error) {
      sql += `-- Error dumping table ${tableName}: ${error}\n\n`
    }
    
    return sql
  }

  /**
   * List all backups (from memory)
   */
  static async listBackups(): Promise<BackupInfo[]> {
    console.log('Listing backups, total in memory:', recentBackups.size)
    const backups = Array.from(recentBackups.values())
    return backups.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
  }

  /**
   * Download a backup
   */
  static async downloadBackup(backupId: string): Promise<string> {
    console.log('BackupService: Downloading backup', backupId)
    console.log('Available backups:', Array.from(recentBackups.keys()))
    console.log('Global backup storage size:', recentBackups.size)
    
    const backup = recentBackups.get(backupId)
    
    if (!backup) {
      console.error('Backup not found in memory:', backupId)
      console.log('All stored backups:', Array.from(recentBackups.entries()).map(([id, b]) => ({ id, filename: b.filename })))
      throw new Error(`Backup not found: ${backupId}`)
    }
    
    if (!backup.content) {
      console.error('Backup content is empty:', backupId)
      throw new Error(`Backup content not available: ${backupId}`)
    }
    
    console.log('Backup content length:', backup.content.length)
    return backup.content
  }

  /**
   * Restore a backup
   */
  static async restoreBackup(backupId: string): Promise<void> {
    const backup = recentBackups.get(backupId)
    
    if (!backup || !backup.content) {
      throw new Error('Backup not found or content not available')
    }

    try {
      // Split SQL into individual statements
      const statements = backup.content
        .split(';')
        .map(stmt => stmt.trim())
        .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'))

      // Execute each statement
      for (const statement of statements) {
        if (statement.length > 0) {
          await prisma.$executeRawUnsafe(statement)
        }
      }
    } catch (error) {
      throw new Error(`Restore failed: ${error}`)
    }
  }

  /**
   * Upload a backup file
   */
  static async uploadBackup(file: File): Promise<BackupInfo> {
    const backupId = crypto.randomUUID()
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `backup-upload-${timestamp}-${backupId}.sql`

    try {
      // Convert File to string
      const arrayBuffer = await file.arrayBuffer()
      const buffer = Buffer.from(arrayBuffer)
      const backupContent = buffer.toString('utf8')

      // Verify the backup file is valid SQL
      if (!backupContent.includes('-- MySQL dump')) {
        throw new Error('Invalid backup file format')
      }

      const backupInfo: BackupInfo = {
        id: backupId,
        filename,
        size: this.formatBytes(buffer.length),
        createdAt: new Date().toISOString(),
        status: 'completed',
        type: 'manual',
        tables: this.TABLES,
        recordCount: await this.getRecordCount(),
        content: backupContent
      }

      // Store in memory
      recentBackups.set(backupId, backupInfo)
      console.log('Uploaded backup stored in memory:', backupId)

      return backupInfo
    } catch (error) {
      throw new Error(`Upload failed: ${error}`)
    }
  }

  /**
   * Delete a backup
   */
  static async deleteBackup(backupId: string): Promise<void> {
    if (!recentBackups.has(backupId)) {
      throw new Error('Backup not found')
    }

    recentBackups.delete(backupId)
    console.log('Backup deleted:', backupId, 'Remaining backups:', recentBackups.size)
  }

  /**
   * Get backup statistics
   */
  static async getStats(): Promise<BackupStats> {
    const backups = await this.listBackups()
    const totalSize = backups.reduce((acc, backup) => {
      const sizeInBytes = this.parseBytes(backup.size)
      return acc + sizeInBytes
    }, 0)

    const lastBackup = backups.length > 0 ? backups[0].createdAt : new Date().toISOString()
    const autoBackupsEnabled = process.env.AUTO_BACKUP_ENABLED === 'true'
    
    // Calculate next auto backup (daily at 2 AM)
    const nextAutoBackup = new Date()
    nextAutoBackup.setHours(2, 0, 0, 0)
    if (nextAutoBackup <= new Date()) {
      nextAutoBackup.setDate(nextAutoBackup.getDate() + 1)
    }

    return {
      totalBackups: backups.length,
      totalSize: this.formatBytes(totalSize),
      lastBackup,
      autoBackupsEnabled,
      nextAutoBackup: nextAutoBackup.toISOString(),
      storageUsed: this.formatBytes(totalSize),
      storageLimit: '100MB' // Memory-based limit
    }
  }

  /**
   * Get total record count across all tables
   */
  private static async getRecordCount(): Promise<number> {
    try {
      const counts = await Promise.all(
        this.TABLES.map(async (table) => {
          try {
            const result = await prisma.$queryRawUnsafe(`SELECT COUNT(*) as count FROM ${table}`)
            return (result as any)[0]?.count || 0
          } catch (error) {
            return 0
          }
        })
      )
      
      return counts.reduce((acc, count) => acc + count, 0)
    } catch (error) {
      return 0
    }
  }

  /**
   * Format bytes to human readable string
   */
  private static formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes'
    
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  /**
   * Parse human readable bytes back to number
   */
  private static parseBytes(sizeStr: string): number {
    const match = sizeStr.match(/^([\d.]+)\s*([KMGT]?B)$/i)
    if (!match) return 0
    
    const [, size, unit] = match
    const multipliers: { [key: string]: number } = {
      'B': 1,
      'KB': 1024,
      'MB': 1024 * 1024,
      'GB': 1024 * 1024 * 1024
    }
    
    return parseFloat(size) * (multipliers[unit.toUpperCase()] || 1)
  }
} 
